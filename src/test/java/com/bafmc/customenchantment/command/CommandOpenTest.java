package com.bafmc.customenchantment.command;

import com.bafmc.bukkit.command.AdvancedCommandBuilder;
import com.bafmc.bukkit.command.ArgumentType;
import com.bafmc.bukkit.command.CommandRegistrar;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

/**
 * Tests for CommandOpen class.
 * Tests open command registration with storage/head/mask/weapon/artifact/sigil/book sub-commands.
 */
@DisplayName("CommandOpen Tests")
class CommandOpenTest {

    private CommandOpen commandOpen;

    @Mock
    private AdvancedCommandBuilder mockBuilder;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        commandOpen = new CommandOpen();
        when(mockBuilder.subCommand(anyString())).thenReturn(mockBuilder);
        when(mockBuilder.subCommand(any(String[].class))).thenReturn(mockBuilder);
        when(mockBuilder.permission(anyString())).thenReturn(mockBuilder);
        when(mockBuilder.commandExecutor(any())).thenReturn(mockBuilder);
        when(mockBuilder.commandExecutorUntilNextCommand(any())).thenReturn(mockBuilder);
        when(mockBuilder.tabCompleter(any())).thenReturn(mockBuilder);
        when(mockBuilder.tabCompleterUntilNextTab(any())).thenReturn(mockBuilder);
        when(mockBuilder.end()).thenReturn(mockBuilder);
    }

    @Nested
    @DisplayName("Interface Implementation Tests")
    class InterfaceTests {

        @Test
        @DisplayName("should implement CommandRegistrar interface")
        void shouldImplementCommandRegistrar() {
            assertInstanceOf(CommandRegistrar.class, commandOpen);
        }

        @Test
        @DisplayName("should be instantiable with no-arg constructor")
        void shouldBeInstantiable() {
            assertNotNull(new CommandOpen());
        }
    }

    @Nested
    @DisplayName("onRegister Tests")
    class OnRegisterTests {

        @Test
        @DisplayName("should register open subcommand")
        void shouldRegisterOpenSubCommand() {
            commandOpen.onRegister(mockBuilder);

            verify(mockBuilder).subCommand("open");
        }

        @Test
        @DisplayName("should register correct permission")
        void shouldRegisterCorrectPermission() {
            commandOpen.onRegister(mockBuilder);

            verify(mockBuilder).permission("customenchantment.open.other");
        }

        @Test
        @DisplayName("should register player argument type")
        void shouldRegisterPlayerArgument() {
            commandOpen.onRegister(mockBuilder);

            verify(mockBuilder).subCommand(ArgumentType.PLAYER);
        }

        @Test
        @DisplayName("should register storage subcommand")
        void shouldRegisterStorageSubCommand() {
            commandOpen.onRegister(mockBuilder);

            verify(mockBuilder).subCommand("storage");
        }

        @Test
        @DisplayName("should register head subcommand")
        void shouldRegisterHeadSubCommand() {
            commandOpen.onRegister(mockBuilder);

            verify(mockBuilder).subCommand("head");
        }

        @Test
        @DisplayName("should register mask subcommand")
        void shouldRegisterMaskSubCommand() {
            commandOpen.onRegister(mockBuilder);

            verify(mockBuilder).subCommand("mask");
        }

        @Test
        @DisplayName("should register weapon subcommand")
        void shouldRegisterWeaponSubCommand() {
            commandOpen.onRegister(mockBuilder);

            verify(mockBuilder).subCommand("weapon");
        }

        @Test
        @DisplayName("should register artifact subcommand")
        void shouldRegisterArtifactSubCommand() {
            commandOpen.onRegister(mockBuilder);

            verify(mockBuilder).subCommand("artifact");
        }

        @Test
        @DisplayName("should register sigil subcommand")
        void shouldRegisterSigilSubCommand() {
            commandOpen.onRegister(mockBuilder);

            verify(mockBuilder).subCommand("sigil");
        }

        @Test
        @DisplayName("should register book subcommand")
        void shouldRegisterBookSubCommand() {
            commandOpen.onRegister(mockBuilder);

            verify(mockBuilder).subCommand("book");
        }

        @Test
        @DisplayName("should register page subcommand for various views")
        void shouldRegisterPageSubCommands() {
            commandOpen.onRegister(mockBuilder);

            // <page> is registered for storage, head, mask, weapon, artifact, sigil
            verify(mockBuilder, atLeast(6)).subCommand("<page>");
        }

        @Test
        @DisplayName("should register group subcommand for book")
        void shouldRegisterGroupSubCommand() {
            commandOpen.onRegister(mockBuilder);

            verify(mockBuilder).subCommand("<group>");
        }

        @Test
        @DisplayName("should register tab completers")
        void shouldRegisterTabCompleters() {
            commandOpen.onRegister(mockBuilder);

            verify(mockBuilder, atLeast(4)).tabCompleter(any());
        }

        @Test
        @DisplayName("should register command executors")
        void shouldRegisterCommandExecutors() {
            commandOpen.onRegister(mockBuilder);

            verify(mockBuilder, atLeast(4)).commandExecutor(any());
        }

        @Test
        @DisplayName("should call end to close command tree")
        void shouldCallEnd() {
            commandOpen.onRegister(mockBuilder);

            verify(mockBuilder, atLeast(10)).end();
        }

        @Test
        @DisplayName("should not throw when registering on builder")
        void shouldNotThrowOnRegister() {
            assertDoesNotThrow(() -> commandOpen.onRegister(mockBuilder));
        }
    }

    @Nested
    @DisplayName("Helper Method Tests")
    class HelperMethodTests {

        @Test
        @DisplayName("should create open executor for given type")
        void shouldCreateOpenExecutor() {
            assertNotNull(commandOpen.getOpenExecutor("mask"));
            assertNotNull(commandOpen.getOpenExecutor("weapon"));
            assertNotNull(commandOpen.getOpenExecutor("artifact"));
        }

        @Test
        @DisplayName("should create open tab completer for given type")
        void shouldCreateOpenTabCompleter() {
            assertNotNull(commandOpen.getOpenTab("mask"));
            assertNotNull(commandOpen.getOpenTab("weapon"));
            assertNotNull(commandOpen.getOpenTab("artifact"));
        }

        @Test
        @DisplayName("should return different executor instances for different types")
        void shouldReturnDifferentExecutors() {
            var exec1 = commandOpen.getOpenExecutor("mask");
            var exec2 = commandOpen.getOpenExecutor("weapon");

            assertNotSame(exec1, exec2);
        }

        @Test
        @DisplayName("should return different tab completer instances for different types")
        void shouldReturnDifferentTabCompleters() {
            var tab1 = commandOpen.getOpenTab("mask");
            var tab2 = commandOpen.getOpenTab("weapon");

            assertNotSame(tab1, tab2);
        }
    }
}
