<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/com/bafmc/customenchantment/SlowLineAttackListener.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/bafmc/customenchantment/SlowLineAttackListener.java" />
              <option name="originalContent" value="package com.bafmc.customenchantment;&#10;&#10;import com.bafmc.bukkit.bafframework.nms.NMSAttributeType;&#10;import com.bafmc.bukkit.utils.EquipSlot;&#10;import com.bafmc.bukkit.utils.RandomUtils;&#10;import com.bafmc.customenchantment.api.CEAPI;&#10;import com.bafmc.customenchantment.api.ParticleSupport;&#10;import com.bafmc.customenchantment.attribute.CustomAttributeType;&#10;import com.bafmc.customenchantment.item.CEWeaponAbstract;&#10;import com.bafmc.customenchantment.item.CEWeaponType;&#10;import com.bafmc.customenchantment.player.CEPlayer;&#10;import net.minecraft.core.particles.DustParticleOptions;&#10;import net.minecraft.core.particles.ParticleOptions;&#10;import org.bukkit.Bukkit;&#10;import org.bukkit.Location;&#10;import org.bukkit.attribute.Attribute;&#10;import org.bukkit.craftbukkit.entity.CraftPlayer;&#10;import org.bukkit.entity.Entity;&#10;import org.bukkit.entity.LivingEntity;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.event.EventHandler;&#10;import org.bukkit.event.Listener;&#10;import org.bukkit.event.entity.EntityDamageByEntityEvent;&#10;import org.bukkit.event.entity.EntityDamageEvent;&#10;import org.bukkit.event.entity.EntityInteractEvent;&#10;import org.bukkit.event.player.PlayerInteractEvent;&#10;import org.bukkit.scheduler.BukkitRunnable;&#10;import org.bukkit.util.Vector;&#10;import org.joml.Vector3f;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public class SlowLineAttackListener implements Listener {&#10;    private Map&lt;String, Long&gt; lastAttackTimeMap = new HashMap&lt;&gt;();&#10;&#10;    private final CustomEnchantment plugin;&#10;&#10;    private final ParticleSupport particleSupport = new ParticleSupport();&#10;&#10;    public long getLastAttackTime(String playerName) {&#10;        return lastAttackTimeMap.getOrDefault(playerName, 0L);&#10;    }&#10;&#10;    public void updateLastAttackTime(String playerName, long time) {&#10;        lastAttackTimeMap.put(playerName, time);&#10;    }&#10;&#10;    public boolean canAttack(String playerName, long cooldownMillis) {&#10;        long lastAttackTime = getLastAttackTime(playerName);&#10;        long currentTime = System.currentTimeMillis();&#10;        return (currentTime - lastAttackTime) &gt;= cooldownMillis;&#10;    }&#10;&#10;    // Particle #00B6B6&#10;    private static final ParticleOptions CYAN_PARTICLE =&#10;            new DustParticleOptions(&#10;                    new Vector3f(0f / 255f, 182f / 255f, 182f / 255f),&#10;                    1.0f&#10;            );&#10;&#10;    public SlowLineAttackListener(CustomEnchantment plugin) {&#10;        this.plugin = plugin;&#10;    }&#10;&#10;    @EventHandler&#10;    public void onAttack(PlayerInteractEvent event) {&#10;        switch (event.getAction()) {&#10;            case LEFT_CLICK_AIR, LEFT_CLICK_BLOCK -&gt; {}&#10;            default -&gt; { return; }&#10;        }&#10;&#10;        Player player = event.getPlayer();&#10;        CEPlayer cePlayer = CEAPI.getCEPlayer(player);&#10;&#10;        CEWeaponAbstract ceWeaponAbstract = cePlayer.getEquipment().getSlot(EquipSlot.MAINHAND, true, true);&#10;        if (ceWeaponAbstract == null) return;&#10;&#10;        if (ceWeaponAbstract.getWeaponType() == CEWeaponType.STAFF) {&#10;            if (!canAttackNow(player)) {&#10;                event.setCancelled(true);&#10;                return;&#10;            }&#10;&#10;            double range = cePlayer.getPlayer().getAttribute(Attribute.PLAYER_ENTITY_INTERACTION_RANGE).getValue();&#10;            double attackDamage = cePlayer.getPlayer().getAttribute(Attribute.GENERIC_ATTACK_DAMAGE).getValue();&#10;            float attackCooldown = getAttackCooldownFactor(player);&#10;&#10;            shootSlowLine(player, range, attackDamage, attackCooldown);&#10;            event.setCancelled(true);&#10;        }&#10;    }&#10;&#10;    public static boolean magicShot = false;&#10;&#10;    @EventHandler&#10;    public void onAttack(EntityDamageByEntityEvent event) {&#10;        if (!magicShot) {&#10;            Player player = (Player) event.getDamager();&#10;            CEPlayer cePlayer = CEAPI.getCEPlayer(player);&#10;            CEWeaponAbstract ceWeaponAbstract = cePlayer.getEquipment().getSlot(EquipSlot.MAINHAND, true, true);&#10;            if (ceWeaponAbstract == null) return;&#10;            if (ceWeaponAbstract.getWeaponType() == CEWeaponType.STAFF) {&#10;                if (!canAttackNow(player)) {&#10;                    event.setCancelled(true);&#10;                    return;&#10;                }&#10;                double range = cePlayer.getPlayer().getAttribute(Attribute.PLAYER_ENTITY_INTERACTION_RANGE).getValue();&#10;                double attackDamage = cePlayer.getPlayer().getAttribute(Attribute.GENERIC_ATTACK_DAMAGE).getValue();&#10;                float attackCooldown = getAttackCooldownFactor(player);&#10;                shootSlowLine(player, range, attackDamage, attackCooldown);&#10;                event.setCancelled(true);&#10;            }&#10;        }else {&#10;            System.out.println(event.getDamager().getLocation().distance(event.getEntity().getLocation()));&#10;        }&#10;    }&#10;&#10;    private void shootSlowLine(Player player, double range, double attackDamage, float attackCooldown) {&#10;        System.out.println(&quot;Slow Line Attack!&quot;);&#10;        Location eye = player.getEyeLocation();&#10;        Vector direction = eye.getDirection().normalize();&#10;&#10;        Vector right = direction.clone()&#10;                .crossProduct(new Vector(0, 1, 0))&#10;                .normalize()&#10;                .multiply(0.5);&#10;&#10;        double startOffset = RandomUtils.random(0.5, 1.25);&#10;&#10;        Location start = eye.clone()&#10;                .add(right)&#10;                .add(direction.clone().multiply(startOffset));&#10;&#10;         double maxDistance = range - startOffset;&#10;        final double speedPerTick = 1.0;&#10;&#10;        Location end = eye.clone().add(direction.clone().multiply(maxDistance));&#10;&#10;        double totalDistance = start.distance(end);&#10;        int totalTicks = (int) Math.ceil(totalDistance / speedPerTick);&#10;&#10;        new BukkitRunnable() {&#10;&#10;            int tick = 0;&#10;            Location prevLoc = start.clone();&#10;&#10;            @Override&#10;            public void run() {&#10;                double progress = (double) tick / totalTicks;&#10;                if (progress &gt;= 1.0) {&#10;                    cancel();&#10;                    return;&#10;                }&#10;&#10;                // Nội suy vị trí&#10;                Vector current = end.toVector()&#10;                        .subtract(start.toVector())&#10;                        .multiply(progress)&#10;                        .add(start.toVector());&#10;&#10;                Location currLoc = current.toLocation(start.getWorld());&#10;&#10;                spawnParticle(currLoc);&#10;                if (checkHitLine(player, prevLoc, currLoc, attackDamage, attackCooldown)) {&#10;                    cancel();&#10;                    return;&#10;                }&#10;&#10;                if (currLoc.getBlock().getType().isSolid()) {&#10;                    cancel();&#10;                    return;&#10;                }&#10;&#10;                prevLoc = currLoc;&#10;                tick++;&#10;            }&#10;&#10;        }.runTaskTimer(plugin, 0L, 1L);&#10;    }&#10;&#10;    /* =========================&#10;     * PARTICLE&#10;     * ========================= */&#10;    private void spawnParticle(Location loc) {&#10;        String worldName = loc.getWorld().getName();&#10;&#10;        for (Player target : Bukkit.getOnlinePlayers()) {&#10;            if (!target.getWorld().getName().equals(worldName)) continue;&#10;            if (target.getLocation().distanceSquared(loc) &gt; 64 * 64) continue;&#10;&#10;            particleSupport.send(&#10;                    target,&#10;                    CYAN_PARTICLE,&#10;                    (float) loc.getX(),&#10;                    (float) loc.getY(),&#10;                    (float) loc.getZ(),&#10;                    0f, 0f, 0f,   // vector&#10;                    1,            // count&#10;                    false         // distance &gt; 255 ?&#10;            );&#10;        }&#10;    }&#10;&#10;    private boolean checkHitLine(Player shooter, Location from, Location to, double attackDamage, float attackCooldown) {&#10;        Vector direction = to.toVector().subtract(from.toVector());&#10;        double length = direction.length();&#10;&#10;        if (length &lt;= 0) return false;&#10;&#10;        Vector rayDir = direction.normalize();&#10;&#10;        for (Entity e : from.getWorld().getNearbyEntities(&#10;                from.clone().add(rayDir.multiply(length / 2)),&#10;                length / 2 + 1,&#10;                2,&#10;                length / 2 + 1&#10;        )) {&#10;&#10;            if (!(e instanceof LivingEntity target)) continue;&#10;            if (target.equals(shooter)) continue;&#10;&#10;            var box = target.getBoundingBox().expand(0.15);&#10;&#10;            if (box.rayTrace(from.toVector(), rayDir, length) != null) {&#10;&#10;                magicShot = true;&#10;                target.damage(getDamageByAttackCooldown(shooter, attackDamage, attackCooldown), shooter);&#10;                magicShot = false;&#10;&#10;                return true;&#10;            }&#10;        }&#10;&#10;        return false;&#10;    }&#10;&#10;    public double getDamageByAttackCooldown(Player shooter, double baseDamage, float attackCooldown) {&#10;        net.minecraft.world.entity.player.Player nmsPlayer = ((CraftPlayer) shooter).getHandle();&#10;&#10;        baseDamage *= (1.0F - Math.sqrt(1.0F - Math.pow(attackCooldown, nmsPlayer.level().purpurConfig.newDamageCurvePower)));&#10;&#10;        return baseDamage;&#10;    }&#10;&#10;    public float getAttackCooldownFactor(Player player) {&#10;        net.minecraft.world.entity.player.Player nmsPlayer = ((CraftPlayer) player).getHandle();&#10;        return nmsPlayer.getAttackStrengthScale(0.5F);&#10;    }&#10;&#10;    public boolean canAttackNow(Player player) {&#10;        float attackCooldown = getAttackCooldownFactor(player);&#10;        return attackCooldown &gt;= CustomEnchantment.instance().getMainConfig().getCombatStaffMinRequiredAttackStrengthScale();&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.bafmc.customenchantment;&#10;&#10;import com.bafmc.bukkit.bafframework.nms.NMSAttributeType;&#10;import com.bafmc.bukkit.utils.EquipSlot;&#10;import com.bafmc.bukkit.utils.RandomUtils;&#10;import com.bafmc.customenchantment.api.CEAPI;&#10;import com.bafmc.customenchantment.api.ParticleSupport;&#10;import com.bafmc.customenchantment.attribute.CustomAttributeType;&#10;import com.bafmc.customenchantment.item.CEWeaponAbstract;&#10;import com.bafmc.customenchantment.item.CEWeaponType;&#10;import com.bafmc.customenchantment.player.CEPlayer;&#10;import net.minecraft.core.particles.DustParticleOptions;&#10;import net.minecraft.core.particles.ParticleOptions;&#10;import org.bukkit.Bukkit;&#10;import org.bukkit.Location;&#10;import org.bukkit.attribute.Attribute;&#10;import org.bukkit.craftbukkit.entity.CraftPlayer;&#10;import org.bukkit.entity.Entity;&#10;import org.bukkit.entity.LivingEntity;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.event.EventHandler;&#10;import org.bukkit.event.Listener;&#10;import org.bukkit.event.entity.EntityDamageByEntityEvent;&#10;import org.bukkit.event.entity.EntityDamageEvent;&#10;import org.bukkit.event.entity.EntityInteractEvent;&#10;import org.bukkit.event.player.PlayerInteractEvent;&#10;import org.bukkit.scheduler.BukkitRunnable;&#10;import org.bukkit.util.Vector;&#10;import org.joml.Vector3f;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public class SlowLineAttackListener implements Listener {&#10;    private Map&lt;String, Long&gt; lastAttackTimeMap = new HashMap&lt;&gt;();&#10;&#10;    private final CustomEnchantment plugin;&#10;&#10;    private final ParticleSupport particleSupport = new ParticleSupport();&#10;&#10;    public long getLastAttackTime(String playerName) {&#10;        return lastAttackTimeMap.getOrDefault(playerName, 0L);&#10;    }&#10;&#10;    public void updateLastAttackTime(String playerName, long time) {&#10;        lastAttackTimeMap.put(playerName, time);&#10;    }&#10;&#10;    public boolean canAttack(String playerName, long cooldownMillis) {&#10;        long lastAttackTime = getLastAttackTime(playerName);&#10;        long currentTime = System.currentTimeMillis();&#10;        return (currentTime - lastAttackTime) &gt;= cooldownMillis;&#10;    }&#10;&#10;    // Particle #00B6B6&#10;    private static final ParticleOptions CYAN_PARTICLE =&#10;            new DustParticleOptions(&#10;                    new Vector3f(0f / 255f, 182f / 255f, 182f / 255f),&#10;                    1.0f&#10;            );&#10;&#10;    public SlowLineAttackListener(CustomEnchantment plugin) {&#10;        this.plugin = plugin;&#10;    }&#10;&#10;    @EventHandler&#10;    public void onAttack(PlayerInteractEvent event) {&#10;        switch (event.getAction()) {&#10;            case LEFT_CLICK_AIR, LEFT_CLICK_BLOCK -&gt; {}&#10;            default -&gt; { return; }&#10;        }&#10;&#10;        Player player = event.getPlayer();&#10;        CEPlayer cePlayer = CEAPI.getCEPlayer(player);&#10;&#10;        CEWeaponAbstract ceWeaponAbstract = cePlayer.getEquipment().getSlot(EquipSlot.MAINHAND, true, true);&#10;        if (ceWeaponAbstract == null) return;&#10;&#10;        if (ceWeaponAbstract.getWeaponType() == CEWeaponType.STAFF) {&#10;            if (!canAttackNow(player)) {&#10;                event.setCancelled(true);&#10;                return;&#10;            }&#10;&#10;            double range = cePlayer.getPlayer().getAttribute(Attribute.PLAYER_ENTITY_INTERACTION_RANGE).getValue();&#10;            double attackDamage = cePlayer.getPlayer().getAttribute(Attribute.GENERIC_ATTACK_DAMAGE).getValue();&#10;            float attackCooldown = getAttackCooldownFactor(player);&#10;&#10;            shootSlowLine(player, range, attackDamage, attackCooldown);&#10;            event.setCancelled(true);&#10;        }&#10;    }&#10;&#10;    public static boolean magicShot = false;&#10;&#10;    @EventHandler&#10;    public void onAttack(EntityDamageByEntityEvent event) {&#10;        if (!magicShot) {&#10;            Player player = (Player) event.getDamager();&#10;            CEPlayer cePlayer = CEAPI.getCEPlayer(player);&#10;            CEWeaponAbstract ceWeaponAbstract = cePlayer.getEquipment().getSlot(EquipSlot.MAINHAND, true, true);&#10;            if (ceWeaponAbstract == null) return;&#10;            if (ceWeaponAbstract.getWeaponType() == CEWeaponType.STAFF) {&#10;                if (!canAttackNow(player)) {&#10;                    event.setCancelled(true);&#10;                    return;&#10;                }&#10;                double range = cePlayer.getPlayer().getAttribute(Attribute.PLAYER_ENTITY_INTERACTION_RANGE).getValue();&#10;                double attackDamage = cePlayer.getPlayer().getAttribute(Attribute.GENERIC_ATTACK_DAMAGE).getValue();&#10;                float attackCooldown = getAttackCooldownFactor(player);&#10;                shootSlowLine(player, range, attackDamage, attackCooldown);&#10;                event.setCancelled(true);&#10;            }&#10;        }else {&#10;            System.out.println(event.getDamager().getLocation().distance(event.getEntity().getLocation()));&#10;        }&#10;    }&#10;&#10;    private void shootSlowLine(Player player, double range, double attackDamage, float attackCooldown) {&#10;        System.out.println(&quot;Slow Line Attack!&quot;);&#10;        Location eye = player.getEyeLocation();&#10;        Vector direction = eye.getDirection().normalize();&#10;&#10;        Vector right = direction.clone()&#10;                .crossProduct(new Vector(0, 1, 0))&#10;                .normalize()&#10;                .multiply(0.5);&#10;&#10;        double startOffset = RandomUtils.random(0.5, 1.25);&#10;&#10;        Location start = eye.clone()&#10;                .add(right)&#10;                .add(direction.clone().multiply(startOffset));&#10;&#10;         double maxDistance = range - startOffset;&#10;        final double speedPerTick = 1.0;&#10;&#10;        Location end = eye.clone().add(direction.clone().multiply(maxDistance));&#10;&#10;        double totalDistance = start.distance(end);&#10;        int totalTicks = (int) Math.ceil(totalDistance / speedPerTick);&#10;&#10;        new BukkitRunnable() {&#10;&#10;            int tick = 0;&#10;            Location prevLoc = start.clone();&#10;&#10;            @Override&#10;            public void run() {&#10;                double progress = (double) tick / totalTicks;&#10;                if (progress &gt;= 1.0) {&#10;                    cancel();&#10;                    return;&#10;                }&#10;&#10;                // Nội suy vị trí&#10;                Vector current = end.toVector()&#10;                        .subtract(start.toVector())&#10;                        .multiply(progress)&#10;                        .add(start.toVector());&#10;&#10;                Location currLoc = current.toLocation(start.getWorld());&#10;&#10;                spawnParticle(currLoc);&#10;                if (checkHitLine(player, prevLoc, currLoc, attackDamage, attackCooldown)) {&#10;                    cancel();&#10;                    return;&#10;                }&#10;&#10;                if (currLoc.getBlock().getType().isSolid()) {&#10;                    cancel();&#10;                    return;&#10;                }&#10;&#10;                prevLoc = currLoc;&#10;                tick++;&#10;            }&#10;&#10;        }.runTaskTimer(plugin, 0L, 1L);&#10;    }&#10;&#10;    /* =========================&#10;     * PARTICLE&#10;     * ========================= */&#10;    private void spawnParticle(Location loc) {&#10;        String worldName = loc.getWorld().getName();&#10;&#10;        for (Player target : Bukkit.getOnlinePlayers()) {&#10;            if (!target.getWorld().getName().equals(worldName)) continue;&#10;            if (target.getLocation().distanceSquared(loc) &gt; 64 * 64) continue;&#10;&#10;            particleSupport.send(&#10;                    target,&#10;                    CYAN_PARTICLE,&#10;                    (float) loc.getX(),&#10;                    (float) loc.getY(),&#10;                    (float) loc.getZ(),&#10;                    0f, 0f, 0f,   // vector&#10;                    1,            // count&#10;                    false         // distance &gt; 255 ?&#10;            );&#10;        }&#10;    }&#10;&#10;    private boolean checkHitLine(Player shooter, Location from, Location to, double attackDamage, float attackCooldown) {&#10;        Vector direction = to.toVector().subtract(from.toVector());&#10;        double length = direction.length();&#10;&#10;        if (length &lt;= 0) return false;&#10;&#10;        Vector rayDir = direction.normalize();&#10;&#10;        for (Entity e : from.getWorld().getNearbyEntities(&#10;                from.clone().add(rayDir.multiply(length / 2)),&#10;                length / 2 + 1,&#10;                2,&#10;                length / 2 + 1&#10;        )) {&#10;&#10;            if (!(e instanceof LivingEntity target)) continue;&#10;            if (target.equals(shooter)) continue;&#10;&#10;            var box = target.getBoundingBox().expand(0.15);&#10;&#10;            if (box.rayTrace(from.toVector(), rayDir, length) != null) {&#10;&#10;                magicShot = true;&#10;                target.damage(getDamageByAttackCooldown(shooter, attackDamage, attackCooldown), shooter);&#10;                magicShot = false;&#10;&#10;                return true;&#10;            }&#10;        }&#10;&#10;        return false;&#10;    }&#10;&#10;    public double getDamageByAttackCooldown(Player shooter, double baseDamage, float attackCooldown) {&#10;        net.minecraft.world.entity.player.Player nmsPlayer = ((CraftPlayer) shooter).getHandle();&#10;&#10;        baseDamage *= (1.0F - Math.sqrt(1.0F - Math.pow(attackCooldown, nmsPlayer.level().purpurConfig.newDamageCurvePower)));&#10;        return baseDamage;&#10;    }&#10;&#10;    public float getAttackCooldownFactor(Player player) {&#10;        net.minecraft.world.entity.player.Player nmsPlayer = ((CraftPlayer) player).getHandle();&#10;        return nmsPlayer.getAttackStrengthScale(0.5F);&#10;    }&#10;&#10;    public boolean canAttackNow(Player player) {&#10;        float attackCooldown = getAttackCooldownFactor(player);&#10;        return attackCooldown &gt;= CustomEnchantment.instance().getMainConfig().getCombatStaffMinRequiredAttackStrengthScale();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>