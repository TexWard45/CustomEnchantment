<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/com/bafmc/customenchantment/SlowLineAttackListener.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/bafmc/customenchantment/SlowLineAttackListener.java" />
              <option name="originalContent" value="package com.bafmc.customenchantment;&#10;&#10;import com.bafmc.bukkit.bafframework.nms.NMSAttributeType;&#10;import com.bafmc.bukkit.utils.EquipSlot;&#10;import com.bafmc.bukkit.utils.RandomUtils;&#10;import com.bafmc.customenchantment.api.CEAPI;&#10;import com.bafmc.customenchantment.api.ParticleSupport;&#10;import com.bafmc.customenchantment.attribute.CustomAttributeType;&#10;import com.bafmc.customenchantment.item.CEWeaponAbstract;&#10;import com.bafmc.customenchantment.item.CEWeaponType;&#10;import com.bafmc.customenchantment.player.CEPlayer;&#10;import net.minecraft.core.particles.DustParticleOptions;&#10;import net.minecraft.core.particles.ParticleOptions;&#10;import org.bukkit.Bukkit;&#10;import org.bukkit.Location;&#10;import org.bukkit.attribute.Attribute;&#10;import org.bukkit.craftbukkit.entity.CraftPlayer;&#10;import org.bukkit.entity.Entity;&#10;import org.bukkit.entity.LivingEntity;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.event.EventHandler;&#10;import org.bukkit.event.Listener;&#10;import org.bukkit.event.entity.EntityDamageByEntityEvent;&#10;import org.bukkit.event.entity.EntityDamageEvent;&#10;import org.bukkit.event.entity.EntityInteractEvent;&#10;import org.bukkit.event.player.PlayerInteractEvent;&#10;import org.bukkit.scheduler.BukkitRunnable;&#10;import org.bukkit.util.Vector;&#10;import org.joml.Vector3f;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public class SlowLineAttackListener implements Listener {&#10;    private Map&lt;String, Long&gt; lastAttackTimeMap = new HashMap&lt;&gt;();&#10;&#10;    private final CustomEnchantment plugin;&#10;&#10;    private final ParticleSupport particleSupport = new ParticleSupport();&#10;&#10;    public long getLastAttackTime(String playerName) {&#10;        return lastAttackTimeMap.getOrDefault(playerName, 0L);&#10;    }&#10;&#10;    public void updateLastAttackTime(String playerName, long time) {&#10;        lastAttackTimeMap.put(playerName, time);&#10;    }&#10;&#10;    public boolean canAttack(String playerName, long cooldownMillis) {&#10;        long lastAttackTime = getLastAttackTime(playerName);&#10;        long currentTime = System.currentTimeMillis();&#10;        return (currentTime - lastAttackTime) &gt;= cooldownMillis;&#10;    }&#10;&#10;    // Particle #00B6B6&#10;    private static final ParticleOptions CYAN_PARTICLE =&#10;            new DustParticleOptions(&#10;                    new Vector3f(0f / 255f, 182f / 255f, 182f / 255f),&#10;                    1.0f&#10;            );&#10;&#10;    public SlowLineAttackListener(CustomEnchantment plugin) {&#10;        this.plugin = plugin;&#10;    }&#10;&#10;    @EventHandler&#10;    public void onAttack(PlayerInteractEvent event) {&#10;        switch (event.getAction()) {&#10;            case LEFT_CLICK_AIR, LEFT_CLICK_BLOCK -&gt; {}&#10;            default -&gt; { return; }&#10;        }&#10;&#10;        Player player = event.getPlayer();&#10;        CEPlayer cePlayer = CEAPI.getCEPlayer(player);&#10;&#10;        CEWeaponAbstract ceWeaponAbstract = cePlayer.getEquipment().getSlot(EquipSlot.MAINHAND, true, true);&#10;        if (ceWeaponAbstract == null) return;&#10;&#10;        if (ceWeaponAbstract.getWeaponType() == CEWeaponType.STAFF) {&#10;            if (!canAttackNow(player)) {&#10;                event.setCancelled(true);&#10;                return;&#10;            }&#10;&#10;            double range = cePlayer.getPlayer().getAttribute(Attribute.PLAYER_ENTITY_INTERACTION_RANGE).getValue();&#10;            double attackDamage = cePlayer.getPlayer().getAttribute(Attribute.GENERIC_ATTACK_DAMAGE).getValue();&#10;            float attackCooldown = getAttackCooldownFactor(player);&#10;&#10;            shootSlowLine(player, range, attackDamage, attackCooldown);&#10;            event.setCancelled(true);&#10;        }&#10;    }&#10;&#10;    public static boolean magicShot = false;&#10;&#10;    @EventHandler&#10;    public void onAttack(EntityDamageByEntityEvent event) {&#10;        if (!magicShot) {&#10;            Player player = (Player) event.getDamager();&#10;            CEPlayer cePlayer = CEAPI.getCEPlayer(player);&#10;            CEWeaponAbstract ceWeaponAbstract = cePlayer.getEquipment().getSlot(EquipSlot.MAINHAND, true, true);&#10;            if (ceWeaponAbstract == null) return;&#10;            if (ceWeaponAbstract.getWeaponType() == CEWeaponType.STAFF) {&#10;                if (!canAttackNow(player)) {&#10;                    event.setCancelled(true);&#10;                    return;&#10;                }&#10;                double range = cePlayer.getPlayer().getAttribute(Attribute.PLAYER_ENTITY_INTERACTION_RANGE).getValue();&#10;                double attackDamage = cePlayer.getPlayer().getAttribute(Attribute.GENERIC_ATTACK_DAMAGE).getValue();&#10;                float attackCooldown = getAttackCooldownFactor(player);&#10;                shootSlowLine(player, range, attackDamage, attackCooldown);&#10;                event.setCancelled(true);&#10;            }&#10;        }else {&#10;            System.out.println(event.getDamager().getLocation().distance(event.getEntity().getLocation()));&#10;        }&#10;    }&#10;&#10;    private void shootSlowLine(Player player, double range, double attackDamage, float attackCooldown) {&#10;        System.out.println(&quot;Slow Line Attack!&quot;);&#10;        Location eye = player.getEyeLocation();&#10;        Vector direction = eye.getDirection().normalize();&#10;&#10;        Vector right = direction.clone()&#10;                .crossProduct(new Vector(0, 1, 0))&#10;                .normalize()&#10;                .multiply(0.5);&#10;&#10;        double startOffset = RandomUtils.random(0.5, 1.25);&#10;&#10;        Location start = eye.clone()&#10;                .add(right)&#10;                .add(direction.clone().multiply(startOffset));&#10;&#10;         double maxDistance = range - startOffset;&#10;        final double speedPerTick = 1.0;&#10;&#10;        Location end = eye.clone().add(direction.clone().multiply(maxDistance));&#10;&#10;        double totalDistance = start.distance(end);&#10;        int totalTicks = (int) Math.ceil(totalDistance / speedPerTick);&#10;&#10;        new BukkitRunnable() {&#10;&#10;            int tick = 0;&#10;            Location prevLoc = start.clone();&#10;&#10;            @Override&#10;            public void run() {&#10;                double progress = (double) tick / totalTicks;&#10;                if (progress &gt;= 1.0) {&#10;                    cancel();&#10;                    return;&#10;                }&#10;&#10;                // Nội suy vị trí&#10;                Vector current = end.toVector()&#10;                        .subtract(start.toVector())&#10;                        .multiply(progress)&#10;                        .add(start.toVector());&#10;&#10;                Location currLoc = current.toLocation(start.getWorld());&#10;&#10;                spawnParticle(currLoc);&#10;                if (checkHitLine(player, prevLoc, currLoc, attackDamage, attackCooldown)) {&#10;                    cancel();&#10;                    return;&#10;                }&#10;&#10;                if (currLoc.getBlock().getType().isSolid()) {&#10;                    cancel();&#10;                    return;&#10;                }&#10;&#10;                prevLoc = currLoc;&#10;                tick++;&#10;            }&#10;&#10;        }.runTaskTimer(plugin, 0L, 1L);&#10;    }&#10;&#10;    /* =========================&#10;     * PARTICLE&#10;     * ========================= */&#10;    private void spawnParticle(Location loc) {&#10;        String worldName = loc.getWorld().getName();&#10;&#10;        for (Player target : Bukkit.getOnlinePlayers()) {&#10;            if (!target.getWorld().getName().equals(worldName)) continue;&#10;            if (target.getLocation().distanceSquared(loc) &gt; 64 * 64) continue;&#10;&#10;            particleSupport.send(&#10;                    target,&#10;                    CYAN_PARTICLE,&#10;                    (float) loc.getX(),&#10;                    (float) loc.getY(),&#10;                    (float) loc.getZ(),&#10;                    0f, 0f, 0f,   // vector&#10;                    1,            // count&#10;                    false         // distance &gt; 255 ?&#10;            );&#10;        }&#10;    }&#10;&#10;    private boolean checkHitLine(Player shooter, Location from, Location to, double attackDamage, float attackCooldown) {&#10;        Vector direction = to.toVector().subtract(from.toVector());&#10;        double length = direction.length();&#10;&#10;        if (length &lt;= 0) return false;&#10;&#10;        Vector rayDir = direction.normalize();&#10;&#10;        for (Entity e : from.getWorld().getNearbyEntities(&#10;                from.clone().add(rayDir.multiply(length / 2)),&#10;                length / 2 + 1,&#10;                2,&#10;                length / 2 + 1&#10;        )) {&#10;&#10;            if (!(e instanceof LivingEntity target)) continue;&#10;            if (target.equals(shooter)) continue;&#10;&#10;            var box = target.getBoundingBox().expand(0.15);&#10;&#10;            if (box.rayTrace(from.toVector(), rayDir, length) != null) {&#10;&#10;                magicShot = true;&#10;                target.damage(getDamageByAttackCooldown(shooter, attackDamage, attackCooldown), shooter);&#10;                magicShot = false;&#10;&#10;                return true;&#10;            }&#10;        }&#10;&#10;        return false;&#10;    }&#10;&#10;    public double getDamageByAttackCooldown(Player shooter, double baseDamage, float attackCooldown) {&#10;        net.minecraft.world.entity.player.Player nmsPlayer = ((CraftPlayer) shooter).getHandle();&#10;&#10;        baseDamage *= (1.0F - Math.sqrt(1.0F - Math.pow(attackCooldown, nmsPlayer.level().purpurConfig.newDamageCurvePower)));&#10;&#10;        return baseDamage;&#10;    }&#10;&#10;    public float getAttackCooldownFactor(Player player) {&#10;        net.minecraft.world.entity.player.Player nmsPlayer = ((CraftPlayer) player).getHandle();&#10;        return nmsPlayer.getAttackStrengthScale(0.5F);&#10;    }&#10;&#10;    public boolean canAttackNow(Player player) {&#10;        float attackCooldown = getAttackCooldownFactor(player);&#10;        return attackCooldown &gt;= CustomEnchantment.instance().getMainConfig().getCombatStaffMinRequiredAttackStrengthScale();&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.bafmc.customenchantment;&#10;&#10;import com.bafmc.bukkit.bafframework.nms.NMSAttributeType;&#10;import com.bafmc.bukkit.utils.EquipSlot;&#10;import com.bafmc.bukkit.utils.RandomUtils;&#10;import com.bafmc.customenchantment.api.CEAPI;&#10;import com.bafmc.customenchantment.api.ParticleSupport;&#10;import com.bafmc.customenchantment.attribute.CustomAttributeType;&#10;import com.bafmc.customenchantment.item.CEWeaponAbstract;&#10;import com.bafmc.customenchantment.item.CEWeaponType;&#10;import com.bafmc.customenchantment.player.CEPlayer;&#10;import net.minecraft.core.particles.DustParticleOptions;&#10;import net.minecraft.core.particles.ParticleOptions;&#10;import org.bukkit.Bukkit;&#10;import org.bukkit.Location;&#10;import org.bukkit.attribute.Attribute;&#10;import org.bukkit.craftbukkit.entity.CraftPlayer;&#10;import org.bukkit.entity.Entity;&#10;import org.bukkit.entity.LivingEntity;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.event.EventHandler;&#10;import org.bukkit.event.Listener;&#10;import org.bukkit.event.entity.EntityDamageByEntityEvent;&#10;import org.bukkit.event.entity.EntityDamageEvent;&#10;import org.bukkit.event.entity.EntityInteractEvent;&#10;import org.bukkit.event.player.PlayerInteractEvent;&#10;import org.bukkit.scheduler.BukkitRunnable;&#10;import org.bukkit.util.Vector;&#10;import org.joml.Vector3f;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public class SlowLineAttackListener implements Listener {&#10;    private Map&lt;String, Long&gt; lastAttackTimeMap = new HashMap&lt;&gt;();&#10;&#10;    private final CustomEnchantment plugin;&#10;&#10;    private final ParticleSupport particleSupport = new ParticleSupport();&#10;&#10;    public long getLastAttackTime(String playerName) {&#10;        return lastAttackTimeMap.getOrDefault(playerName, 0L);&#10;    }&#10;&#10;    public void updateLastAttackTime(String playerName, long time) {&#10;        lastAttackTimeMap.put(playerName, time);&#10;    }&#10;&#10;    public boolean canAttack(String playerName, long cooldownMillis) {&#10;        long lastAttackTime = getLastAttackTime(playerName);&#10;        long currentTime = System.currentTimeMillis();&#10;        return (currentTime - lastAttackTime) &gt;= cooldownMillis;&#10;    }&#10;&#10;    // Particle #00B6B6&#10;    private static final ParticleOptions CYAN_PARTICLE =&#10;            new DustParticleOptions(&#10;                    new Vector3f(0f / 255f, 182f / 255f, 182f / 255f),&#10;                    1.0f&#10;            );&#10;&#10;    public SlowLineAttackListener(CustomEnchantment plugin) {&#10;        this.plugin = plugin;&#10;    }&#10;&#10;    @EventHandler&#10;    public void onAttack(PlayerInteractEvent event) {&#10;        switch (event.getAction()) {&#10;            case LEFT_CLICK_AIR, LEFT_CLICK_BLOCK -&gt; {}&#10;            default -&gt; { return; }&#10;        }&#10;&#10;        Player player = event.getPlayer();&#10;        CEPlayer cePlayer = CEAPI.getCEPlayer(player);&#10;&#10;        CEWeaponAbstract ceWeaponAbstract = cePlayer.getEquipment().getSlot(EquipSlot.MAINHAND, true, true);&#10;        if (ceWeaponAbstract == null) return;&#10;&#10;        if (ceWeaponAbstract.getWeaponType() == CEWeaponType.STAFF) {&#10;            if (!canAttackNow(player)) {&#10;                event.setCancelled(true);&#10;                return;&#10;            }&#10;&#10;            double range = cePlayer.getPlayer().getAttribute(Attribute.PLAYER_ENTITY_INTERACTION_RANGE).getValue();&#10;            double attackDamage = cePlayer.getPlayer().getAttribute(Attribute.GENERIC_ATTACK_DAMAGE).getValue();&#10;            float attackCooldown = getAttackCooldownFactor(player);&#10;&#10;            shootSlowLine(player, range, attackDamage, attackCooldown);&#10;            event.setCancelled(true);&#10;        }&#10;    }&#10;&#10;    public static boolean magicShot = false;&#10;&#10;    @EventHandler&#10;    public void onAttack(EntityDamageByEntityEvent event) {&#10;        if (!magicShot) {&#10;            Player player = (Player) event.getDamager();&#10;            CEPlayer cePlayer = CEAPI.getCEPlayer(player);&#10;            CEWeaponAbstract ceWeaponAbstract = cePlayer.getEquipment().getSlot(EquipSlot.MAINHAND, true, true);&#10;            if (ceWeaponAbstract == null) return;&#10;            if (ceWeaponAbstract.getWeaponType() == CEWeaponType.STAFF) {&#10;                if (!canAttackNow(player)) {&#10;                    event.setCancelled(true);&#10;                    return;&#10;                }&#10;                double range = cePlayer.getPlayer().getAttribute(Attribute.PLAYER_ENTITY_INTERACTION_RANGE).getValue();&#10;                double attackDamage = cePlayer.getPlayer().getAttribute(Attribute.GENERIC_ATTACK_DAMAGE).getValue();&#10;                float attackCooldown = getAttackCooldownFactor(player);&#10;                shootSlowLine(player, range, attackDamage, attackCooldown);&#10;                event.setCancelled(true);&#10;            }&#10;        }else {&#10;            System.out.println(event.getDamager().getLocation().distance(event.getEntity().getLocation()));&#10;        }&#10;    }&#10;&#10;    private void shootSlowLine(Player player, double range, double attackDamage, float attackCooldown) {&#10;        System.out.println(&quot;Slow Line Attack!&quot;);&#10;        Location eye = player.getEyeLocation();&#10;        Vector direction = eye.getDirection().normalize();&#10;&#10;        Vector right = direction.clone()&#10;                .crossProduct(new Vector(0, 1, 0))&#10;                .normalize()&#10;                .multiply(0.5);&#10;&#10;        double startOffset = RandomUtils.random(0.5, 1.25);&#10;&#10;        Location start = eye.clone()&#10;                .add(right)&#10;                .add(direction.clone().multiply(startOffset));&#10;&#10;         double maxDistance = range - startOffset;&#10;        final double speedPerTick = 1.0;&#10;&#10;        Location end = eye.clone().add(direction.clone().multiply(maxDistance));&#10;&#10;        double totalDistance = start.distance(end);&#10;        int totalTicks = (int) Math.ceil(totalDistance / speedPerTick);&#10;&#10;        new BukkitRunnable() {&#10;&#10;            int tick = 0;&#10;            Location prevLoc = start.clone();&#10;&#10;            @Override&#10;            public void run() {&#10;                double progress = (double) tick / totalTicks;&#10;                if (progress &gt;= 1.0) {&#10;                    cancel();&#10;                    return;&#10;                }&#10;&#10;                // Nội suy vị trí&#10;                Vector current = end.toVector()&#10;                        .subtract(start.toVector())&#10;                        .multiply(progress)&#10;                        .add(start.toVector());&#10;&#10;                Location currLoc = current.toLocation(start.getWorld());&#10;&#10;                spawnParticle(currLoc);&#10;                if (checkHitLine(player, prevLoc, currLoc, attackDamage, attackCooldown)) {&#10;                    cancel();&#10;                    return;&#10;                }&#10;&#10;                if (currLoc.getBlock().getType().isSolid()) {&#10;                    cancel();&#10;                    return;&#10;                }&#10;&#10;                prevLoc = currLoc;&#10;                tick++;&#10;            }&#10;&#10;        }.runTaskTimer(plugin, 0L, 1L);&#10;    }&#10;&#10;    /* =========================&#10;     * PARTICLE&#10;     * ========================= */&#10;    private void spawnParticle(Location loc) {&#10;        String worldName = loc.getWorld().getName();&#10;&#10;        for (Player target : Bukkit.getOnlinePlayers()) {&#10;            if (!target.getWorld().getName().equals(worldName)) continue;&#10;            if (target.getLocation().distanceSquared(loc) &gt; 64 * 64) continue;&#10;&#10;            particleSupport.send(&#10;                    target,&#10;                    CYAN_PARTICLE,&#10;                    (float) loc.getX(),&#10;                    (float) loc.getY(),&#10;                    (float) loc.getZ(),&#10;                    0f, 0f, 0f,   // vector&#10;                    1,            // count&#10;                    false         // distance &gt; 255 ?&#10;            );&#10;        }&#10;    }&#10;&#10;    private boolean checkHitLine(Player shooter, Location from, Location to, double attackDamage, float attackCooldown) {&#10;        Vector direction = to.toVector().subtract(from.toVector());&#10;        double length = direction.length();&#10;&#10;        if (length &lt;= 0) return false;&#10;&#10;        Vector rayDir = direction.normalize();&#10;&#10;        for (Entity e : from.getWorld().getNearbyEntities(&#10;                from.clone().add(rayDir.multiply(length / 2)),&#10;                length / 2 + 1,&#10;                2,&#10;                length / 2 + 1&#10;        )) {&#10;&#10;            if (!(e instanceof LivingEntity target)) continue;&#10;            if (target.equals(shooter)) continue;&#10;&#10;            var box = target.getBoundingBox().expand(0.15);&#10;&#10;            if (box.rayTrace(from.toVector(), rayDir, length) != null) {&#10;&#10;                magicShot = true;&#10;                target.damage(getDamageByAttackCooldown(shooter, attackDamage, attackCooldown), shooter);&#10;                magicShot = false;&#10;&#10;                return true;&#10;            }&#10;        }&#10;&#10;        return false;&#10;    }&#10;&#10;    public double getDamageByAttackCooldown(Player shooter, double baseDamage, float attackCooldown) {&#10;        net.minecraft.world.entity.player.Player nmsPlayer = ((CraftPlayer) shooter).getHandle();&#10;&#10;        baseDamage *= (1.0F - Math.sqrt(1.0F - Math.pow(attackCooldown, nmsPlayer.level().purpurConfig.newDamageCurvePower)));&#10;        return baseDamage;&#10;    }&#10;&#10;    public float getAttackCooldownFactor(Player player) {&#10;        net.minecraft.world.entity.player.Player nmsPlayer = ((CraftPlayer) player).getHandle();&#10;        return nmsPlayer.getAttackStrengthScale(0.5F);&#10;    }&#10;&#10;    public boolean canAttackNow(Player player) {&#10;        float attackCooldown = getAttackCooldownFactor(player);&#10;        return attackCooldown &gt;= CustomEnchantment.instance().getMainConfig().getCombatStaffMinRequiredAttackStrengthScale();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/bafmc/customenchantment/task/PowerAsyncTask.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/bafmc/customenchantment/task/PowerAsyncTask.java" />
              <option name="originalContent" value="package com.bafmc.customenchantment.task;&#10;&#10;import com.bafmc.bukkit.bafframework.nms.NMSAttributeOperation;&#10;import com.bafmc.customenchantment.CustomEnchantment;&#10;import com.bafmc.customenchantment.api.CEAPI;&#10;import com.bafmc.customenchantment.attribute.CustomAttributeType;&#10;import com.bafmc.customenchantment.attribute.RangeAttribute;&#10;import com.bafmc.customenchantment.player.CEPlayer;&#10;import com.bafmc.customenchantment.player.PlayerCustomAttribute;&#10;import com.bafmc.customenchantment.player.PlayerVanillaAttribute;&#10;import org.apache.poi.ss.usermodel.*;&#10;import org.apache.poi.xssf.usermodel.XSSFWorkbook;&#10;import org.bukkit.Bukkit;&#10;import org.bukkit.attribute.Attribute;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.scheduler.BukkitRunnable;&#10;&#10;import java.io.File;&#10;import java.io.FileInputStream;&#10;&#10;public class PowerAsyncTask extends BukkitRunnable {&#10;    private CustomEnchantment plugin;&#10;    private Workbook workbook;&#10;    private FormulaEvaluator evaluator;&#10;    private Sheet sheet;&#10;&#10;    public PowerAsyncTask(CustomEnchantment plugin) {&#10;        this.plugin = plugin;&#10;        try {&#10;            File file = getPowerCalculatorFile();&#10;            FileInputStream fis = new FileInputStream(file);&#10;            this.workbook = new XSSFWorkbook(fis);&#10;            this.workbook.setForceFormulaRecalculation(true);&#10;            this.evaluator = workbook.getCreationHelper().createFormulaEvaluator();&#10;            this.evaluator.evaluateAll();&#10;            this.sheet = workbook.getSheetAt(0);&#10;            fis.close();&#10;        } catch (Exception e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    public void run() {&#10;        for (Player player : Bukkit.getOnlinePlayers()) {&#10;            run(player);&#10;        }&#10;    }&#10;&#10;    public void run(Player player) {&#10;        CEPlayer cePlayer = CEAPI.getCEPlayer(player);&#10;        PlayerVanillaAttribute vanillaAttribute = cePlayer.getVanillaAttribute();&#10;        PlayerCustomAttribute customAttribute = cePlayer.getCustomAttribute();&#10;&#10;        if (workbook == null || evaluator == null || sheet == null) return;&#10;&#10;        // Map of Excel cell positions and their corresponding values&#10;        setCellValue(2, 3, player.getAttribute(Attribute.GENERIC_MAX_HEALTH).getValue()); // D3: Health&#10;        setCellValue(5, 3, player.getAttribute(Attribute.GENERIC_ARMOR).getValue()); // D6: Armor&#10;        setCellValue(11, 3, player.getAttribute(Attribute.GENERIC_ATTACK_DAMAGE).getValue()); // D12: Damage&#10;        setCellValue(12, 3, player.getAttribute(Attribute.GENERIC_ATTACK_SPEED).getValue()); // D13: Attack Speed&#10;        setCellValue(13, 3, customAttribute.getValue(CustomAttributeType.CRITICAL_DAMAGE)); // D14: Critical Damage&#10;        setCellValue(14, 3, customAttribute.getValue(CustomAttributeType.CRITICAL_CHANCE)); // D15: Critical Chance&#10;&#10;        evaluator.clearAllCachedResultValues();&#10;        evaluator.evaluateAll();&#10;&#10;        double defensePower = Math.round(readEvaluatedCell(sheet, evaluator, 24, 11)); // L25&#10;        double attackPower = Math.round(readEvaluatedCell(sheet, evaluator, 25, 11));  // L26&#10;&#10;        customAttribute.addCustomAttribute(&quot;TOTAL_POWER&quot;,&#10;                new RangeAttribute(CustomAttributeType.TOTAL_POWER, attackPower + defensePower, NMSAttributeOperation.ADD_NUMBER));&#10;        customAttribute.addCustomAttribute(&quot;ATK_POWER&quot;,&#10;                new RangeAttribute(CustomAttributeType.ATK_POWER, attackPower, NMSAttributeOperation.ADD_NUMBER));&#10;        customAttribute.addCustomAttribute(&quot;DEF_POWER&quot;,&#10;                new RangeAttribute(CustomAttributeType.DEF_POWER, defensePower, NMSAttributeOperation.ADD_NUMBER));&#10;    }&#10;&#10;    private void setCellValue(int rowIdx, int colIdx, double value) {&#10;        Row row = sheet.getRow(rowIdx);&#10;        if (row == null) row = sheet.createRow(rowIdx);&#10;        Cell cell = row.getCell(colIdx);&#10;        if (cell == null) cell = row.createCell(colIdx);&#10;        cell.setCellValue(value);&#10;    }&#10;&#10;    static double readEvaluatedCell(Sheet sheet, FormulaEvaluator evaluator, int row, int col) {&#10;        Row r = sheet.getRow(row);&#10;        if (r == null) return 0;&#10;        Cell c = r.getCell(col);&#10;        if (c == null) return 0;&#10;        CellValue cv = evaluator.evaluate(c);&#10;        return cv != null ? cv.getNumberValue() : 0;&#10;    }&#10;&#10;    public File getPowerCalculatorFile() {&#10;        return new File(plugin.getDataFolder(), &quot;PowerCalculator.xlsx&quot;);&#10;    }&#10;&#10;    public void close() {&#10;        try {&#10;            if (workbook != null) {&#10;                workbook.close();&#10;            }&#10;        } catch (Exception e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.bafmc.customenchantment.task;&#10;&#10;import com.bafmc.bukkit.bafframework.nms.NMSAttributeOperation;&#10;import com.bafmc.customenchantment.CustomEnchantment;&#10;import com.bafmc.customenchantment.api.CEAPI;&#10;import com.bafmc.customenchantment.attribute.CustomAttributeType;&#10;import com.bafmc.customenchantment.attribute.RangeAttribute;&#10;import com.bafmc.customenchantment.player.CEPlayer;&#10;import com.bafmc.customenchantment.player.PlayerCustomAttribute;&#10;import com.bafmc.customenchantment.player.PlayerVanillaAttribute;&#10;import org.apache.poi.ss.usermodel.*;&#10;import org.apache.poi.xssf.usermodel.XSSFWorkbook;&#10;import org.bukkit.Bukkit;&#10;import org.bukkit.attribute.Attribute;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.scheduler.BukkitRunnable;&#10;&#10;import java.io.File;&#10;import java.io.FileInputStream;&#10;import java.util.LinkedHashMap;&#10;import java.util.Map;&#10;&#10;public class PowerAsyncTask extends BukkitRunnable {&#10;    private CustomEnchantment plugin;&#10;    private Workbook workbook;&#10;    private FormulaEvaluator evaluator;&#10;    private Sheet sheet;&#10;&#10;    // Attribute mapping: row index (D3 = 2, D4 = 3, ..., D24 = 23)&#10;    private static final LinkedHashMap&lt;Integer, AttributeSetter&gt; ATTRIBUTE_SETTERS = new LinkedHashMap&lt;&gt;();&#10;    static {&#10;        ATTRIBUTE_SETTERS.put(2, (player, vanilla, custom) -&gt; player.getAttribute(Attribute.GENERIC_MAX_HEALTH).getValue()); // Max Health&#10;        ATTRIBUTE_SETTERS.put(3, (player, vanilla, custom) -&gt; custom.getValue(CustomAttributeType.STAT_ABSORPTION_HEART)); // Max Absorption&#10;        ATTRIBUTE_SETTERS.put(4, (player, vanilla, custom) -&gt; custom.getValue(CustomAttributeType.HEALTH_REGENERATION)); // Health Regeneration&#10;        ATTRIBUTE_SETTERS.put(5, (player, vanilla, custom) -&gt; player.getAttribute(Attribute.GENERIC_ARMOR).getValue()); // Armor&#10;        ATTRIBUTE_SETTERS.put(6, (player, vanilla, custom) -&gt; custom.getValue(CustomAttributeType.DAMAGE_REDUCTION)); // Damage Reduction&#10;        ATTRIBUTE_SETTERS.put(7, (player, vanilla, custom) -&gt; player.getAttribute(Attribute.GENERIC_MOVEMENT_SPEED).getValue()); // Movement Speed&#10;        ATTRIBUTE_SETTERS.put(8, (player, vanilla, custom) -&gt; custom.getValue(CustomAttributeType.DODGE_CHANCE)); // Dodge Chance&#10;        ATTRIBUTE_SETTERS.put(9, (player, vanilla, custom) -&gt; custom.getValue(CustomAttributeType.SLOW_RESISTANCE)); // Slow Resistance&#10;        ATTRIBUTE_SETTERS.put(10, (player, vanilla, custom) -&gt; custom.getValue(CustomAttributeType.MAGIC_RESISTANCE)); // Magic Resistance&#10;        ATTRIBUTE_SETTERS.put(11, (player, vanilla, custom) -&gt; player.getAttribute(Attribute.GENERIC_ATTACK_DAMAGE).getValue()); // Attack Damage&#10;        ATTRIBUTE_SETTERS.put(12, (player, vanilla, custom) -&gt; player.getAttribute(Attribute.GENERIC_ATTACK_SPEED).getValue()); // Attack Speed&#10;        ATTRIBUTE_SETTERS.put(13, (player, vanilla, custom) -&gt; custom.getValue(CustomAttributeType.CRITICAL_DAMAGE)); // Critical Damage (Multiply)&#10;        ATTRIBUTE_SETTERS.put(14, (player, vanilla, custom) -&gt; custom.getValue(CustomAttributeType.CRITICAL_CHANCE)); // Critical Chance&#10;        ATTRIBUTE_SETTERS.put(15, (player, vanilla, custom) -&gt; custom.getValue(CustomAttributeType.ARMOR_PENETRATION)); // Armor Penetration&#10;        ATTRIBUTE_SETTERS.put(16, (player, vanilla, custom) -&gt; custom.getValue(CustomAttributeType.LIFE_STEAL)); // Life Steal&#10;        ATTRIBUTE_SETTERS.put(17, (player, vanilla, custom) -&gt; custom.getValue(CustomAttributeType.OPTION_ATTACK)); // Attack Range (custom, adjust if needed)&#10;        ATTRIBUTE_SETTERS.put(18, (player, vanilla, custom) -&gt; custom.getValue(CustomAttributeType.AOE_RANGE)); // Aoe Range&#10;        ATTRIBUTE_SETTERS.put(19, (player, vanilla, custom) -&gt; custom.getValue(CustomAttributeType.AOE_DAMAGE_RATIO)); // Aoe Damage Ratio&#10;        ATTRIBUTE_SETTERS.put(20, (player, vanilla, custom) -&gt; custom.getValue(CustomAttributeType.ACCURACY_CHANCE)); // Accuracy Chance&#10;        ATTRIBUTE_SETTERS.put(21, (player, vanilla, custom) -&gt; custom.getValue(CustomAttributeType.OPTION_DEFENSE)); // Grievous Wounds (custom, adjust if needed)&#10;        ATTRIBUTE_SETTERS.put(22, (player, vanilla, custom) -&gt; custom.getValue(CustomAttributeType.VULNERABILITY)); // Vulnerability&#10;        ATTRIBUTE_SETTERS.put(23, (player, vanilla, custom) -&gt; custom.getValue(CustomAttributeType.MINING_POWER)); // Mining Power&#10;    }&#10;&#10;    @FunctionalInterface&#10;    private interface AttributeSetter {&#10;        double get(Player player, PlayerVanillaAttribute vanilla, PlayerCustomAttribute custom);&#10;    }&#10;&#10;    public PowerAsyncTask(CustomEnchantment plugin) {&#10;        this.plugin = plugin;&#10;        try {&#10;            File file = getPowerCalculatorFile();&#10;            FileInputStream fis = new FileInputStream(file);&#10;            this.workbook = new XSSFWorkbook(fis);&#10;            this.workbook.setForceFormulaRecalculation(true);&#10;            this.evaluator = workbook.getCreationHelper().createFormulaEvaluator();&#10;            this.evaluator.evaluateAll();&#10;            this.sheet = workbook.getSheetAt(0);&#10;            fis.close();&#10;        } catch (Exception e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    public void run() {&#10;        for (Player player : Bukkit.getOnlinePlayers()) {&#10;            run(player);&#10;        }&#10;    }&#10;&#10;    public void run(Player player) {&#10;        CEPlayer cePlayer = CEAPI.getCEPlayer(player);&#10;        PlayerVanillaAttribute vanillaAttribute = cePlayer.getVanillaAttribute();&#10;        PlayerCustomAttribute customAttribute = cePlayer.getCustomAttribute();&#10;&#10;        if (workbook == null || evaluator == null || sheet == null) return;&#10;&#10;        // Set all attributes from D3 to D24&#10;        for (Map.Entry&lt;Integer, AttributeSetter&gt; entry : ATTRIBUTE_SETTERS.entrySet()) {&#10;            setCellValue(entry.getKey(), 3, entry.getValue().get(player, vanillaAttribute, customAttribute));&#10;        }&#10;&#10;        evaluator.clearAllCachedResultValues();&#10;        evaluator.evaluateAll();&#10;&#10;        double defensePower = Math.round(readEvaluatedCell(sheet, evaluator, 24, 11)); // L25&#10;        double attackPower = Math.round(readEvaluatedCell(sheet, evaluator, 25, 11));  // L26&#10;&#10;        customAttribute.addCustomAttribute(&quot;TOTAL_POWER&quot;,&#10;                new RangeAttribute(CustomAttributeType.TOTAL_POWER, attackPower + defensePower, NMSAttributeOperation.ADD_NUMBER));&#10;        customAttribute.addCustomAttribute(&quot;ATK_POWER&quot;,&#10;                new RangeAttribute(CustomAttributeType.ATK_POWER, attackPower, NMSAttributeOperation.ADD_NUMBER));&#10;        customAttribute.addCustomAttribute(&quot;DEF_POWER&quot;,&#10;                new RangeAttribute(CustomAttributeType.DEF_POWER, defensePower, NMSAttributeOperation.ADD_NUMBER));&#10;    }&#10;&#10;    private void setCellValue(int rowIdx, int colIdx, double value) {&#10;        Row row = sheet.getRow(rowIdx);&#10;        if (row == null) row = sheet.createRow(rowIdx);&#10;        Cell cell = row.getCell(colIdx);&#10;        if (cell == null) cell = row.createCell(colIdx);&#10;        cell.setCellValue(value);&#10;    }&#10;&#10;    static double readEvaluatedCell(Sheet sheet, FormulaEvaluator evaluator, int row, int col) {&#10;        Row r = sheet.getRow(row);&#10;        if (r == null) return 0;&#10;        Cell c = r.getCell(col);&#10;        if (c == null) return 0;&#10;        CellValue cv = evaluator.evaluate(c);&#10;        return cv != null ? cv.getNumberValue() : 0;&#10;    }&#10;&#10;    public File getPowerCalculatorFile() {&#10;        return new File(plugin.getDataFolder(), &quot;PowerCalculator.xlsx&quot;);&#10;    }&#10;&#10;    public void close() {&#10;        try {&#10;            if (workbook != null) {&#10;                workbook.close();&#10;            }&#10;        } catch (Exception e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>